// Copyright (c) 2023, The Monero Project
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification, are
// permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this list of
//    conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice, this list
//    of conditions and the following disclaimer in the documentation and/or other
//    materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its contributors may be
//    used to endorse or promote products derived from this software without specific
//    prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include "legacy_knowledge_proofs.h"

#include <boost/thread/pthread/recursive_mutex.hpp>
#include <string>

#include "common/base58.h"
#include "crypto/crypto.h"
#include "crypto/hash.h"

// #include "net/parse.h"
#include "cryptonote_basic/cryptonote_basic.h"
#include "net/http.h"
#include "net/http_client.h"
#include "rpc/core_rpc_server_commands_defs.h"
#include "rpc/core_rpc_server_error_codes.h"
#include "seraphis_impl/enote_store.h"
#include "seraphis_main/contextual_enote_record_types.h"
#include "storages/http_abstract_invoke.h"
#include "wallet/wallet_errors.h"
// #include "rpc/core_rpc_server_error_codes.h"

//----------------------------------------------------------------------------------------------------
std::string get_legacy_spend_proof(const std::string &message,
    const crypto::hash &txid,
    const crypto::secret_key &spend_key,
    const sp::SpEnoteStore &enote_store)
{
    // 1. get tx info
    epee::net_utils::http::http_simple_client http_client;
    constexpr const std::chrono::seconds rpc_timeout = std::chrono::minutes(3) + std::chrono::seconds(30);

    http_client.set_server("127.0.0.1:18081", boost::none);
    http_client.connect(rpc_timeout);

    cryptonote::COMMAND_RPC_GET_TRANSACTIONS::request req = AUTO_VAL_INIT(req);
    req.txs_hashes.push_back(epee::string_tools::pod_to_hex(txid));
    req.decode_as_json                                     = true;
    req.prune                                              = true;
    cryptonote::COMMAND_RPC_GET_TRANSACTIONS::response res = AUTO_VAL_INIT(res);
    bool r;

    r = epee::net_utils::invoke_http_json("/gettransactions", req, res, http_client, rpc_timeout);
    THROW_WALLET_EXCEPTION_IF(!r, tools::error::wallet_internal_error, "Failed to get transaction from daemon");

    cryptonote::transaction tx;
    crypto::hash tx_hash;
    THROW_WALLET_EXCEPTION_IF(!get_pruned_tx(res.txs[0], tx, tx_hash),
        tools::error::wallet_internal_error,
        "Failed to get tx from daemon");

    // 2. get signature prefix hash
    std::string sig_prefix_data((const char *)&txid, sizeof(crypto::hash));
    sig_prefix_data += message;
    crypto::hash sig_prefix_hash;
    crypto::cn_fast_hash(sig_prefix_data.data(), sig_prefix_data.size(), sig_prefix_hash);

    std::vector<std::vector<crypto::signature>> signatures;
    // 3. loop over all inputs

    for (size_t i = 0; i < tx.vin.size(); i++)
    {
        const cryptonote::txin_to_key *const in_key = boost::get<cryptonote::txin_to_key>(std::addressof(tx.vin[i]));
        if (in_key == nullptr) continue;
        // 3.1 check if the key image belongs to us
        // check if the key image belongs to us
        if (!enote_store.has_enote_with_key_image(in_key->k_image))
        {
            THROW_WALLET_EXCEPTION_IF(true,
                tools::error::wallet_internal_error,
                "This tx wasn't generated by this wallet!");
        }

        // 3.2 derive the real output keypair
        // TODO
        sp::LegacyContextualEnoteRecordV1 contextual_record;
        enote_store.try_get_legacy_enote_record(in_key->k_image, contextual_record);
        rct::key tx_out_pk     = contextual_record.record.enote_ephemeral_pubkey;
        rct::key pub_key_enote = sp::onetime_address_ref(contextual_record.record.enote);
        crypto::secret_key sec_key_enote;
        sc_add(to_bytes(sec_key_enote), to_bytes(contextual_record.record.enote_view_extension), to_bytes(spend_key));
        THROW_WALLET_EXCEPTION_IF(in_key->k_image != contextual_record.record.key_image,
            tools::error::wallet_internal_error,
            "key image mismatch");

        // 3.3 get output pubkeys in the ring
        const std::vector<uint64_t> absolute_offsets =
            cryptonote::relative_output_offsets_to_absolute(in_key->key_offsets);
        const size_t ring_size = in_key->key_offsets.size();
        THROW_WALLET_EXCEPTION_IF(absolute_offsets.size() != ring_size,
            tools::error::wallet_internal_error,
            "absolute offsets size is wrong");
        cryptonote::COMMAND_RPC_GET_OUTPUTS_BIN::request req = AUTO_VAL_INIT(req);
        req.outputs.resize(ring_size);
        for (size_t j = 0; j < ring_size; ++j)
        {
            req.outputs[j].amount = in_key->amount;
            req.outputs[j].index  = absolute_offsets[j];
        }
        cryptonote::COMMAND_RPC_GET_OUTPUTS_BIN::response res = AUTO_VAL_INIT(res);
        bool r;
        {
            //   const boost::lock_guard<boost::recursive_mutex> lock{m_daemon_rpc_mutex};
            r = epee::net_utils::invoke_http_bin("/get_outs.bin", req, res, http_client, rpc_timeout);
            // THROW_ON_RPC_RESPONSE_ERROR(r, {}, res, "get_outs.bin", tools::error::get_outs_error, res.status);
            THROW_WALLET_EXCEPTION_IF(res.outs.size() != ring_size,
                tools::error::wallet_internal_error,
                "daemon returned wrong response for get_outs.bin, wrong amounts count = " +
                    std::to_string(res.outs.size()) + ", expected " + std::to_string(ring_size));
        }

        // 3.4 copy pubkey pointers
        std::vector<const crypto::public_key *> p_output_keys;
        for (const cryptonote::COMMAND_RPC_GET_OUTPUTS_BIN::outkey &out : res.outs) p_output_keys.push_back(&out.key);

        // 3.5 figure out real output index and secret key
        size_t sec_index = -1;
        for (size_t j = 0; j < ring_size; ++j)
        {
            if ((rct::key &)res.outs[j].key == pub_key_enote)
            {
                sec_index = j;
                break;
            }
        }
        THROW_WALLET_EXCEPTION_IF(sec_index >= ring_size,
            tools::error::wallet_internal_error,
            "secret index not found");

        // 3.6 generate ring sig for this input
        signatures.push_back(std::vector<crypto::signature>());
        std::vector<crypto::signature> &sigs = signatures.back();
        sigs.resize(in_key->key_offsets.size());
        crypto::generate_ring_signature(sig_prefix_hash,
            in_key->k_image,
            p_output_keys,
            sec_key_enote,
            sec_index,
            sigs.data());
    }

    std::string sig_str = "SpendProofV1";
    for (const std::vector<crypto::signature> &ring_sig : signatures)
        for (const crypto::signature &sig : ring_sig)
            sig_str += tools::base58::encode(std::string((const char *)&sig, sizeof(crypto::signature)));
    return sig_str;
}
//----------------------------------------------------------------------------------------------------
bool check_spend_proof(const crypto::hash &txid, const std::string &message, const std::string &sig_str)
{
    epee::net_utils::http::http_simple_client http_client;
    constexpr const std::chrono::seconds rpc_timeout = std::chrono::minutes(3) + std::chrono::seconds(30);

    http_client.set_server("127.0.0.1:18081", boost::none);
    http_client.connect(rpc_timeout);

    const std::string header = "SpendProofV1";
    const size_t header_len  = header.size();
    THROW_WALLET_EXCEPTION_IF(sig_str.size() < header_len || sig_str.substr(0, header_len) != header,
        tools::error::wallet_internal_error,
        "Signature header check error");

    // fetch tx from daemon
    cryptonote::COMMAND_RPC_GET_TRANSACTIONS::request req = AUTO_VAL_INIT(req);
    req.txs_hashes.push_back(epee::string_tools::pod_to_hex(txid));
    req.decode_as_json                                     = false;
    req.prune                                              = true;
    cryptonote::COMMAND_RPC_GET_TRANSACTIONS::response res = AUTO_VAL_INIT(res);
    bool r;
    {
        // const boost::lock_guard<boost::recursive_mutex> lock{m_daemon_rpc_mutex};
        r = epee::net_utils::invoke_http_json("/gettransactions", req, res, http_client, rpc_timeout);
        // THROW_ON_RPC_RESPONSE_ERROR_GENERIC(r, {}, res, "gettransactions");
        THROW_WALLET_EXCEPTION_IF(res.txs.size() != 1,
            tools::error::wallet_internal_error,
            "daemon returned wrong response for gettransactions, wrong txs count = " + std::to_string(res.txs.size()) +
                ", expected 1");
    }

    cryptonote::transaction tx;
    crypto::hash tx_hash;
    THROW_WALLET_EXCEPTION_IF(!get_pruned_tx(res.txs[0], tx, tx_hash),
        tools::error::wallet_internal_error,
        "failed to get tx from daemon");

    // check signature size
    size_t num_sigs = 0;
    for (size_t i = 0; i < tx.vin.size(); ++i)
    {
        const cryptonote::txin_to_key *const in_key = boost::get<cryptonote::txin_to_key>(std::addressof(tx.vin[i]));
        if (in_key != nullptr) num_sigs += in_key->key_offsets.size();
    }
    std::vector<std::vector<crypto::signature>> signatures = {std::vector<crypto::signature>(1)};
    const size_t sig_len =
        tools::base58::encode(std::string((const char *)&signatures[0][0], sizeof(crypto::signature))).size();
    if (sig_str.size() != header_len + num_sigs * sig_len)
    {
        return false;
    }

    // decode base58
    signatures.clear();
    size_t offset = header_len;
    for (size_t i = 0; i < tx.vin.size(); ++i)
    {
        const cryptonote::txin_to_key *const in_key = boost::get<cryptonote::txin_to_key>(std::addressof(tx.vin[i]));
        if (in_key == nullptr) continue;
        signatures.resize(signatures.size() + 1);
        signatures.back().resize(in_key->key_offsets.size());
        for (size_t j = 0; j < in_key->key_offsets.size(); ++j)
        {
            std::string sig_decoded;
            THROW_WALLET_EXCEPTION_IF(!tools::base58::decode(sig_str.substr(offset, sig_len), sig_decoded),
                tools::error::wallet_internal_error,
                "Signature decoding error");
            THROW_WALLET_EXCEPTION_IF(sizeof(crypto::signature) != sig_decoded.size(),
                tools::error::wallet_internal_error,
                "Signature decoding error");
            memcpy(&signatures.back()[j], sig_decoded.data(), sizeof(crypto::signature));
            offset += sig_len;
        }
    }

    // get signature prefix hash
    std::string sig_prefix_data((const char *)&txid, sizeof(crypto::hash));
    sig_prefix_data += message;
    crypto::hash sig_prefix_hash;
    crypto::cn_fast_hash(sig_prefix_data.data(), sig_prefix_data.size(), sig_prefix_hash);

    std::vector<std::vector<crypto::signature>>::const_iterator sig_iter = signatures.cbegin();
    for (size_t i = 0; i < tx.vin.size(); ++i)
    {
        const cryptonote::txin_to_key *const in_key = boost::get<cryptonote::txin_to_key>(std::addressof(tx.vin[i]));
        if (in_key == nullptr) continue;

        // get output pubkeys in the ring
        cryptonote::COMMAND_RPC_GET_OUTPUTS_BIN::request req = AUTO_VAL_INIT(req);
        const std::vector<uint64_t> absolute_offsets =
            cryptonote::relative_output_offsets_to_absolute(in_key->key_offsets);
        req.outputs.resize(absolute_offsets.size());
        for (size_t j = 0; j < absolute_offsets.size(); ++j)
        {
            req.outputs[j].amount = in_key->amount;
            req.outputs[j].index  = absolute_offsets[j];
        }
        cryptonote::COMMAND_RPC_GET_OUTPUTS_BIN::response res = AUTO_VAL_INIT(res);
        bool r;
        {
            //   const boost::lock_guard<boost::recursive_mutex> lock{m_daemon_rpc_mutex};
            r = epee::net_utils::invoke_http_bin("/get_outs.bin", req, res, http_client, rpc_timeout);
            // THROW_ON_RPC_RESPONSE_ERROR(r, {}, res, "get_outs.bin", tools::error::get_outs_error, res.status);
            THROW_WALLET_EXCEPTION_IF(res.outs.size() != req.outputs.size(),
                tools::error::wallet_internal_error,
                "daemon returned wrong response for get_outs.bin, wrong amounts count = " +
                    std::to_string(res.outs.size()) + ", expected " + std::to_string(req.outputs.size()));
        }

        // copy pointers
        std::vector<const crypto::public_key *> p_output_keys;
        for (const cryptonote::COMMAND_RPC_GET_OUTPUTS_BIN::outkey &out : res.outs) p_output_keys.push_back(&out.key);

        // check this ring
        if (!crypto::check_ring_signature(sig_prefix_hash, in_key->k_image, p_output_keys, sig_iter->data()))
            return false;
        ++sig_iter;
    }
    THROW_WALLET_EXCEPTION_IF(sig_iter != signatures.cend(),
        tools::error::wallet_internal_error,
        "Signature iterator didn't reach the end");
    return true;
}
//----------------------------------------------------------------------------------------------------
bool get_pruned_tx(const cryptonote::COMMAND_RPC_GET_TRANSACTIONS::entry &entry,
    cryptonote::transaction &tx,
    crypto::hash &tx_hash)
{
    cryptonote::blobdata bd;

    // easy case if we have the whole tx
    if (!entry.as_hex.empty() || (!entry.prunable_as_hex.empty() && !entry.pruned_as_hex.empty()))
    {
        CHECK_AND_ASSERT_MES(epee::string_tools::parse_hexstr_to_binbuff(
                                 entry.as_hex.empty() ? entry.pruned_as_hex + entry.prunable_as_hex : entry.as_hex,
                                 bd),
            false,
            "Failed to parse tx data");
        CHECK_AND_ASSERT_MES(cryptonote::parse_and_validate_tx_from_blob(bd, tx), false, "Invalid tx data");
        tx_hash = cryptonote::get_transaction_hash(tx);
        // if the hash was given, check it matches
        CHECK_AND_ASSERT_MES(entry.tx_hash.empty() || epee::string_tools::pod_to_hex(tx_hash) == entry.tx_hash,
            false,
            "Response claims a different hash than the data yields");
        return true;
    }
    // case of a pruned tx with its prunable data hash
    if (!entry.pruned_as_hex.empty() && !entry.prunable_hash.empty())
    {
        crypto::hash ph;
        CHECK_AND_ASSERT_MES(epee::string_tools::hex_to_pod(entry.prunable_hash, ph),
            false,
            "Failed to parse prunable hash");
        CHECK_AND_ASSERT_MES(epee::string_tools::parse_hexstr_to_binbuff(entry.pruned_as_hex, bd),
            false,
            "Failed to parse pruned data");
        CHECK_AND_ASSERT_MES(parse_and_validate_tx_base_from_blob(bd, tx), false, "Invalid base tx data");
        // only v2 txes can calculate their txid after pruned
        if (bd[0] > 1)
        {
            tx_hash = cryptonote::get_pruned_transaction_hash(tx, ph);
        }
        else
        {
            // for v1, we trust the dameon
            CHECK_AND_ASSERT_MES(epee::string_tools::hex_to_pod(entry.tx_hash, tx_hash),
                false,
                "Failed to parse tx hash");
        }
        return true;
    }
    return false;
}
